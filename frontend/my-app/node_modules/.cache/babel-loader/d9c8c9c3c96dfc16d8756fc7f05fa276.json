{"ast":null,"code":"import React, { createContext, useState, useRef, useEffect, useContext } from 'react';\nimport SockJS from 'sockjs-client';\nimport { Client } from '@stomp/stompjs';\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nvar StompContext = createContext(undefined);\nvar _excluded = [\"url\", \"children\", \"stompClientOptions\"];\n\nfunction StompSessionProvider(props) {\n  var url = props.url,\n      children = props.children,\n      stompClientOptions = props.stompClientOptions,\n      stompOptions = _objectWithoutPropertiesLoose(props, _excluded);\n\n  if (stompClientOptions) stompOptions = stompClientOptions;\n\n  var _useState = useState(undefined),\n      client = _useState[0],\n      setClient = _useState[1];\n\n  var subscriptionRequests = useRef(new Map());\n  useEffect(function () {\n    var _client = new Client(stompOptions);\n\n    if (!stompOptions.brokerURL && !stompOptions.webSocketFactory) {\n      _client.webSocketFactory = function () {\n        var _window, _window$location;\n\n        var parsedUrl = new URL(url, (_window = window) === null || _window === void 0 ? void 0 : (_window$location = _window.location) === null || _window$location === void 0 ? void 0 : _window$location.href);\n\n        if (parsedUrl.protocol === 'http:' || parsedUrl.protocol === 'https:') {\n          return new SockJS(url);\n        } else if (parsedUrl.protocol === 'ws:' || parsedUrl.protocol === 'wss:') {\n          return new WebSocket(url);\n        } else throw new Error('Protocol not supported');\n      };\n    }\n\n    _client.onConnect = function (frame) {\n      if (stompOptions.onConnect) stompOptions.onConnect(frame);\n      subscriptionRequests.current.forEach(function (value) {\n        value.subscription = _client.subscribe(value.destination, value.callback, value.headers);\n      });\n    };\n\n    if (!stompOptions.onStompError) {\n      _client.onStompError = function (frame) {\n        throw frame;\n      };\n    }\n\n    _client.activate();\n\n    setClient(_client);\n    return function () {\n      _client.deactivate();\n    };\n  }, [url].concat(Object.values(stompOptions)));\n\n  var subscribe = function subscribe(destination, callback, headers) {\n    if (headers === void 0) {\n      headers = {};\n    }\n\n    var subscriptionId = Math.random().toString(36).substr(2, 9);\n    var subscriptionRequest = {\n      destination: destination,\n      callback: callback,\n      headers: headers\n    };\n    subscriptionRequests.current.set(subscriptionId, subscriptionRequest);\n\n    if (client && client.connected) {\n      subscriptionRequest.subscription = client.subscribe(destination, callback, headers);\n    }\n\n    return function () {\n      var subscriptionData = subscriptionRequests.current.get(subscriptionId);\n\n      if (subscriptionData.subscription) {\n        subscriptionData.subscription.unsubscribe();\n      }\n\n      subscriptionRequests.current[\"delete\"](subscriptionId);\n    };\n  };\n\n  return React.createElement(StompContext.Provider, {\n    value: {\n      client: client,\n      subscribe: subscribe\n    }\n  }, children);\n}\n\nfunction useSubscription(destinations, onMessage, headers) {\n  if (headers === void 0) {\n    headers = {};\n  }\n\n  var stompContext = useContext(StompContext);\n  if (stompContext === undefined) throw new Error('There must be a StompSessionProver as Ancestor of all Stomp Hooks and HOCs');\n  var callbackRef = useRef(onMessage);\n\n  var _destinations = Array.isArray(destinations) ? destinations : [destinations];\n\n  callbackRef.current = onMessage;\n  useEffect(function () {\n    var cleanUpFunctions = [];\n\n    _destinations.forEach(function (_destination) {\n      return cleanUpFunctions.push(stompContext.subscribe(_destination, function (message) {\n        callbackRef.current(message);\n      }, headers));\n    });\n\n    return function () {\n      cleanUpFunctions.forEach(function (_cleanUpFunction) {\n        _cleanUpFunction();\n      });\n    };\n  }, [].concat(Object.values(_destinations), Object.values(headers)));\n}\n\nfunction useStompClient() {\n  var context = useContext(StompContext);\n  if (context === undefined) throw new Error('There must be a StompSessionProver as Ancestor of all Stomp Hooks and HOCs');\n  return context.client;\n}\n\nfunction withStompClient(WrappedComponent) {\n  return function (props) {\n    var stompClient = useStompClient();\n    return React.createElement(WrappedComponent, Object.assign({\n      stompClient: stompClient\n    }, props));\n  };\n}\n\nfunction withSubscription(WrappedComponent, destinations, headers) {\n  if (headers === void 0) {\n    headers = {};\n  }\n\n  return function (props) {\n    var ref = useRef();\n    useSubscription(destinations, function (message) {\n      if (ref.current) ref.current.onMessage(message);\n    }, headers);\n    return React.createElement(WrappedComponent, Object.assign({\n      ref: ref\n    }, props));\n  };\n}\n\nexport { StompSessionProvider, useStompClient, useSubscription, withStompClient, withSubscription };","map":{"version":3,"sources":["/root/Downloads/springboot_react/frontend/my-app/node_modules/react-stomp-hooks/src/context/StompContext.tsx","/root/Downloads/springboot_react/frontend/my-app/node_modules/react-stomp-hooks/src/components/StompSessionProvider.tsx","/root/Downloads/springboot_react/frontend/my-app/node_modules/react-stomp-hooks/src/hooks/useSubscription.tsx","/root/Downloads/springboot_react/frontend/my-app/node_modules/react-stomp-hooks/src/hooks/useStompClient.tsx","/root/Downloads/springboot_react/frontend/my-app/node_modules/react-stomp-hooks/src/hoc/withStompClient.tsx","/root/Downloads/springboot_react/frontend/my-app/node_modules/react-stomp-hooks/src/hoc/withSubscription.tsx"],"names":["StompContext","createContext","url","children","stompClientOptions","stompOptions","props","client","setClient","useState","subscriptionRequests","useRef","useEffect","_client","parsedUrl","window","value","Object","subscribe","headers","subscriptionId","Math","subscriptionRequest","destination","callback","subscriptionData","stompContext","useContext","callbackRef","_destinations","Array","cleanUpFunctions","_cleanUpFunction","context","stompClient","useStompClient","React","ref","useSubscription"],"mappings":"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","sourcesContent":["import { createContext } from 'react';\nimport { StompSessionProviderContext } from '../interfaces/StompSessionProviderContext';\n\nconst StompContext = createContext<StompSessionProviderContext | undefined>(\n  undefined\n);\n\nexport default StompContext;\n","import React, { useEffect, useRef, useState } from 'react';\nimport StompContext from '../context/StompContext';\nimport SockJS from 'sockjs-client';\nimport {\n  Client,\n  IStompSocket,\n  messageCallbackType,\n  StompHeaders\n} from '@stomp/stompjs';\nimport { StompSessionProviderProps } from '../interfaces/StompSessionProviderProps';\nimport { StompSessionSubscription } from '../interfaces/StompSessionSubscription';\n\n/**\n * The StompSessionProvider manages the STOMP connection\n * All Hooks and HOCs in this library require an ancestor of this type.\n * The URL to connect to can be specified via the url prop.\n * Depending on the Schema of the URL either Sockjs or a raw Websocket is used.\n * You can override this behavior with the brokerURL or webSocketFactory props, which will then be forwarded to @stomp/stompjs\n * Custom @stomp/stompjs options can be used as props.\n * Please consult the @stomp/stompjs documentation for more information.\n */\nfunction StompSessionProvider(props: StompSessionProviderProps) {\n  let { url, children, stompClientOptions, ...stompOptions } = props;\n\n  // Support old API\n  if (stompClientOptions) stompOptions = stompClientOptions;\n\n  const [client, setClient] = useState<Client | undefined>(undefined);\n  const subscriptionRequests = useRef(new Map());\n\n  useEffect(() => {\n    const _client = new Client(stompOptions);\n\n    if (!stompOptions.brokerURL && !stompOptions.webSocketFactory) {\n      _client.webSocketFactory = function () {\n        const parsedUrl = new URL(url, window?.location?.href);\n        if (parsedUrl.protocol === 'http:' || parsedUrl.protocol === 'https:') {\n          return new SockJS(url) as IStompSocket;\n        } else if (\n          parsedUrl.protocol === 'ws:' ||\n          parsedUrl.protocol === 'wss:'\n        ) {\n          return new WebSocket(url) as IStompSocket;\n        } else throw new Error('Protocol not supported');\n      };\n    }\n\n    _client.onConnect = function (frame) {\n      if (stompOptions.onConnect) stompOptions.onConnect(frame);\n\n      subscriptionRequests.current.forEach((value) => {\n        value.subscription = _client.subscribe(\n          value.destination,\n          value.callback,\n          value.headers\n        );\n      });\n    };\n\n    if (!stompOptions.onStompError) {\n      _client.onStompError = function (frame) {\n        throw frame;\n      };\n    }\n\n    _client.activate();\n    setClient(_client);\n\n    return () => {\n      _client.deactivate();\n    };\n  }, [url, ...Object.values(stompOptions)]);\n\n  const subscribe = (\n    destination: string,\n    callback: messageCallbackType,\n    headers: StompHeaders = {}\n  ) => {\n    const subscriptionId = Math.random().toString(36).substr(2, 9);\n    const subscriptionRequest: StompSessionSubscription = {\n      destination,\n      callback,\n      headers\n    };\n\n    subscriptionRequests.current.set(subscriptionId, subscriptionRequest);\n\n    if (client && client.connected) {\n      subscriptionRequest.subscription = client.subscribe(\n        destination,\n        callback,\n        headers\n      );\n    }\n\n    return () => {\n      const subscriptionData = subscriptionRequests.current.get(subscriptionId);\n\n      if (subscriptionData.subscription) {\n        subscriptionData.subscription.unsubscribe();\n      }\n\n      subscriptionRequests.current.delete(subscriptionId);\n    };\n  };\n\n  return (\n    <StompContext.Provider\n      value={{\n        client,\n        subscribe\n      }}\n    >\n      {children}\n    </StompContext.Provider>\n  );\n}\n\nexport default StompSessionProvider;\n","import { useContext, useEffect, useRef } from 'react';\nimport StompContext from '../context/StompContext';\nimport { messageCallbackType, StompHeaders } from '@stomp/stompjs';\n\n/**\n *\n * @param destinations The destinations to subscribe to. Can be a string for a single destination or an array of strings for multiple.\n * @param onMessage Callback called when a message arrives for this subscription\n * @param headers Additional Headers for this subscription, consult @stomp/stompjs docs.\n */\nfunction useSubscription(\n  destinations: string | string[],\n  onMessage: messageCallbackType,\n  headers: StompHeaders = {}\n) {\n  const stompContext = useContext(StompContext);\n\n  if (stompContext === undefined)\n    throw new Error(\n      'There must be a StompSessionProver as Ancestor of all Stomp Hooks and HOCs'\n    );\n\n  const callbackRef = useRef<messageCallbackType>(onMessage);\n  const _destinations = Array.isArray(destinations)\n    ? destinations\n    : [destinations];\n\n  callbackRef.current = onMessage;\n\n  useEffect(() => {\n    const cleanUpFunctions: (() => void)[] = [];\n\n    _destinations.forEach((_destination) =>\n      cleanUpFunctions.push(\n        stompContext.subscribe(\n          _destination,\n          (message) => {\n            callbackRef.current(message);\n          },\n          headers\n        )\n      )\n    );\n\n    return () => {\n      cleanUpFunctions.forEach((_cleanUpFunction) => {\n        _cleanUpFunction();\n      });\n    };\n  }, [...Object.values(_destinations), ...Object.values(headers)]);\n}\n\nexport default useSubscription;\n","import { useContext } from 'react';\nimport StompContext from '../context/StompContext';\nimport { StompSessionProviderContext } from '../interfaces/StompSessionProviderContext';\n\n/**\n * Returns the Stomp Client from @stomp/stompjs\n */\nfunction useStompClient() {\n  const context = useContext<StompSessionProviderContext | undefined>(\n    StompContext\n  );\n\n  if (context === undefined)\n    throw new Error(\n      'There must be a StompSessionProver as Ancestor of all Stomp Hooks and HOCs'\n    );\n\n  return context.client;\n}\n\nexport default useStompClient;\n","import React from 'react';\nimport useStompClient from '../hooks/useStompClient';\n\nfunction withStompClient<P>(WrappedComponent: React.ComponentType<P>) {\n  return (props: P) => {\n    const stompClient = useStompClient();\n    return <WrappedComponent stompClient={stompClient} {...props} />;\n  };\n}\n\nexport default withStompClient;\n","import React, { useRef } from 'react';\nimport useSubscription from '../hooks/useSubscription';\nimport { StompHeaders } from '@stomp/stompjs';\nimport {\n  MessageReceiverInterface,\n  StompMessageReceiver\n} from '../interfaces/StompMessageReceiver';\nimport { IMessage } from '@stomp/stompjs/esm6/i-message';\n\nfunction withSubscription<P>(\n  WrappedComponent: StompMessageReceiver<P>,\n  destinations: string | string[],\n  headers: StompHeaders = {}\n) {\n  return (props: P) => {\n    const ref = useRef<MessageReceiverInterface>();\n    useSubscription(\n      destinations,\n      (message: IMessage) => {\n        if (ref.current) ref.current.onMessage(message);\n      },\n      headers\n    );\n\n    // @ts-ignore\n    return <WrappedComponent ref={ref} {...props} />;\n  };\n}\n\nexport default withSubscription;\n"]},"metadata":{},"sourceType":"module"}