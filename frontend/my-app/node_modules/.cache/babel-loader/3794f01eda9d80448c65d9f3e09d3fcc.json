{"ast":null,"code":"import React, { createContext, useState, useRef, useEffect, useContext } from 'react';\nimport SockJS from 'sockjs-client';\nimport { Client } from '@stomp/stompjs';\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nvar StompContext = createContext(undefined);\nvar _excluded = [\"url\", \"children\", \"stompClientOptions\"];\n\nfunction StompSessionProvider(props) {\n  var url = props.url,\n      children = props.children,\n      stompClientOptions = props.stompClientOptions,\n      stompOptions = _objectWithoutPropertiesLoose(props, _excluded);\n\n  if (stompClientOptions) stompOptions = stompClientOptions;\n\n  var _useState = useState(undefined),\n      client = _useState[0],\n      setClient = _useState[1];\n\n  var subscriptionRequests = useRef(new Map());\n  useEffect(function () {\n    var _client = new Client(stompOptions);\n\n    if (!stompOptions.brokerURL && !stompOptions.webSocketFactory) {\n      _client.webSocketFactory = function () {\n        var _window, _window$location;\n\n        var parsedUrl = new URL(url, (_window = window) === null || _window === void 0 ? void 0 : (_window$location = _window.location) === null || _window$location === void 0 ? void 0 : _window$location.href);\n\n        if (parsedUrl.protocol === 'http:' || parsedUrl.protocol === 'https:') {\n          return new SockJS(url);\n        } else if (parsedUrl.protocol === 'ws:' || parsedUrl.protocol === 'wss:') {\n          return new WebSocket(url);\n        } else throw new Error('Protocol not supported');\n      };\n    }\n\n    _client.onConnect = function (frame) {\n      if (stompOptions.onConnect) stompOptions.onConnect(frame);\n      subscriptionRequests.current.forEach(function (value) {\n        value.subscription = _client.subscribe(value.destination, value.callback, value.headers);\n      });\n    };\n\n    if (!stompOptions.onStompError) {\n      _client.onStompError = function (frame) {\n        throw frame;\n      };\n    }\n\n    _client.activate();\n\n    setClient(_client);\n    return function () {\n      _client.deactivate();\n    };\n  }, [url].concat(Object.values(stompOptions)));\n\n  var subscribe = function subscribe(destination, callback, headers) {\n    if (headers === void 0) {\n      headers = {};\n    }\n\n    var subscriptionId = Math.random().toString(36).substr(2, 9);\n    var subscriptionRequest = {\n      destination: destination,\n      callback: callback,\n      headers: headers\n    };\n    subscriptionRequests.current.set(subscriptionId, subscriptionRequest);\n\n    if (client && client.connected) {\n      subscriptionRequest.subscription = client.subscribe(destination, callback, headers);\n    }\n\n    return function () {\n      var subscriptionData = subscriptionRequests.current.get(subscriptionId);\n\n      if (subscriptionData.subscription) {\n        subscriptionData.subscription.unsubscribe();\n      }\n\n      subscriptionRequests.current[\"delete\"](subscriptionId);\n    };\n  };\n\n  return React.createElement(StompContext.Provider, {\n    value: {\n      client: client,\n      subscribe: subscribe\n    }\n  }, children);\n}\n\nfunction useSubscription(destinations, onMessage, headers) {\n  if (headers === void 0) {\n    headers = {};\n  }\n\n  var stompContext = useContext(StompContext);\n  if (stompContext === undefined) throw new Error('There must be a StompSessionProver as Ancestor of all Stomp Hooks and HOCs');\n  var callbackRef = useRef(onMessage);\n\n  var _destinations = Array.isArray(destinations) ? destinations : [destinations];\n\n  callbackRef.current = onMessage;\n  useEffect(function () {\n    var cleanUpFunctions = [];\n\n    _destinations.forEach(function (_destination) {\n      return cleanUpFunctions.push(stompContext.subscribe(_destination, function (message) {\n        callbackRef.current(message);\n      }, headers));\n    });\n\n    return function () {\n      cleanUpFunctions.forEach(function (_cleanUpFunction) {\n        _cleanUpFunction();\n      });\n    };\n  }, [].concat(Object.values(_destinations), Object.values(headers)));\n}\n\nfunction useStompClient() {\n  var context = useContext(StompContext);\n  if (context === undefined) throw new Error('There must be a StompSessionProver as Ancestor of all Stomp Hooks and HOCs');\n  return context.client;\n}\n\nfunction withStompClient(WrappedComponent) {\n  return function (props) {\n    var stompClient = useStompClient();\n    return React.createElement(WrappedComponent, Object.assign({\n      stompClient: stompClient\n    }, props));\n  };\n}\n\nfunction withSubscription(WrappedComponent, destinations, headers) {\n  if (headers === void 0) {\n    headers = {};\n  }\n\n  return function (props) {\n    var ref = useRef();\n    useSubscription(destinations, function (message) {\n      if (ref.current) ref.current.onMessage(message);\n    }, headers);\n    return React.createElement(WrappedComponent, Object.assign({\n      ref: ref\n    }, props));\n  };\n}\n\nexport { StompSessionProvider, useStompClient, useSubscription, withStompClient, withSubscription };","map":null,"metadata":{},"sourceType":"module"}